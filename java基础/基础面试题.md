# 基础

## 面向对象和面向过程的区别
面向过程

优点： 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗
资源;比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发，性能是
最重要的因素。

缺点： 没有面向对象易维护、易复用、易扩展

面向对象

优点： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特
性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护

缺点： 性能比面向过程低
## Java 语言有哪些特点
1. 简单易学；
2. 面向对象（封装，继承，多态）；
3. 平台无关性（ Java 虚拟机实现平台无关性）；
4. 可靠性；
5. 安全性；
6. 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系
统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程
支持）；
7. 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设
计的，因此 Java 语言不仅支持网络编程而且很方便）；
8. 编译与解释并存；
## 关于 JVM JDK 和 JRE 最详细通俗的解答
JVM

Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特
定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给
出相同的结果。

什么是字节码?采用字节码的好处是什么? 在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文
件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方
式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解
释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码
并不专对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同的计
算机上运行。

Java 程序从源代码到运行一般有下面 3 步：

我们需要格外注意的是 .class->机器码 这一步。在这一步 jvm 类加载器首先
加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对
比较慢。而且，有些方法和代码块是经常需要被调用的，也就是所谓的热点代
码，所以后面引进了 JIT 编译器，JIT 属于运行时编译。当 JIT 编译器完成第
一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我
们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什
么经常会说 Java 是编译与解释共存的语言。

HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分
系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译
的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，
因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式
AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就
避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，
AOT 编译器的编译质量是肯定比不上 JIT 编译器的。

总结：Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系
统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们
都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编
译，随处可以运行”的关键所在。

JDK 和 JRE

JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有
的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编
译程序。

JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，
包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但
是，它不能用于创建新程序。

如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。
如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但
是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然
需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，
您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用
程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译
servlet。

## Oracle JDK 和 OpenJDK 的对比
可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么
Oracle 和 OpenJDK 之间是否存在重大差异？下面通过我通过我收集到一些资
料对你解答这个被很多人忽视的问题。

对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot
源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。
关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有
一个更详细的答案：

## OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？
非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添
加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart
的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三
方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未
来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部
分。

总结：

1. Oracle JDK 版本将每三年发布一次，而 OpenJDK 版本每三个月发布一
次；

2. OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是
OpenJDK 的一个实现，并不是完全开源的；

3. Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎
相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发
企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和
稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应
用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；

4. 顶级公司正在使用 Oracle JDK，例如 Android Studio，Minecraft 和
IntelliJ IDEA 开发工具，其中 Open JDK 不太受欢迎；

5. 在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的
性能；

6. Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过
更新到最新版本获得支持来获取最新版本；

7. Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL
v2 许可获得许可。

5. Java 和 C++的区别
我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比
呀！没办法！！！就算没学过 C++，也要记下来！

* 都是面向对象的语言，都支持封装、继承和多态
* Java 不提供指针来直接访问内存，程序内存更加安全
* Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多
继承，但是接口可以多继承。
* Java 有自动内存管理机制，不需要程序员手动释放无用内存
## 什么是 Java 程序的主类 应用程序和小程序的主类有何不同
一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这
个主类是指包含 main（）方法的类。而在 Java 小程序中，这个主类是一个继
承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public
类，但小程序的主类要求必须是 public 类。主类是 Java 程序执行的入口点。
##  Java 应用程序与小程序之间有那些差别
简单说应用程序是从主线程启动(也就是 main() 方法)。applet 小程序没有
main 方法，主要是嵌在浏览器页面上运行(调用 init()线程或者 run()来启动)，嵌
入浏览器这点跟 flash 的小游戏类似。
##  字符型常量和字符串常量的区别
1. 形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的
若干个字符

2. 含义上: 字符常量相当于一个整形值( ASCII 值),可以参加表达式运算 字
符串常量代表一个地址值(该字符串在内存中存放位置)

3. 占内存大小 字符常量只占 2 个字节 字符串常量占若干个字节(至少一个
字符结束标志) (注意： char 在 Java 中占两个字节)

## 构造器 Constructor 是否可被 override
在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以
Constructor 也就不能被 override（重写）,但是可以 overload（重载）,所以
你可以看到一个类中有多个构造函数的情况。
## 重载和重写的区别
重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序
不同，方法返回值和访问修饰符可以不同，发生在编译时。

重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父
类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类
方法访问修饰符为 private 则子类就不能重写该方法。

## Java 面向对象编程三大特性: 封装 继承 多态
封装

封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，
如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个
类没有提供给外界访问的方法，那么这个类也没有什么意义了。

继承

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加
新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过
使用继承我们能够非常方便地复用以前的代码。
关于继承如下 3 点请记住：

1. 子类拥有父类非 private 的属性和方法。

2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。

3. 子类可以用自己的方式实现父类的方法。（以后介绍）。

多态

所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发
出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变
量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中
实现的方法，必须在由程序运行期间才能决定。

在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接
口（实现接口并覆盖接口中同一方法）。

## String StringBuffer 和 StringBuilder 的区别是什么 String 为什么是不可变的可变性
简单的来说：String 类中使用 final 关键字字符数组保存字符串，private
final char value[]，所以 String 对象是不可变的。而 StringBuilder 与
StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中
也是使用字符数组保存字符串 char[]value 但是没有用 final 关键字修饰，所以
这两种对象都是可变的。

StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是
AbstractStringBuilder 实现的，大家可以自行查阅源码。
```
AbstractStringBuilder.java
abstract class AbstractStringBuilder implements Appendable, CharSequence {
 char[] value;
 int count;
 AbstractStringBuilder() {
 }
 AbstractStringBuilder(int capacity) {
 value = new char[capacity];
 }
 ```
线程安全性
String 中的对象是不可变的，也就可以理解为常量，线程安全。
AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了
一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公
共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以
是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全
的。

性能

每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将
指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身
进行操作，而不是生成新的对象并改变对象引用。相同情况下使用
StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，
但却要冒多线程不安全的风险。

对于三者使用的总结：

1. 操作少量的数据 = String

2. 单线程操作字符串缓冲区下操作大量数据 = StringBuilder

3. 多线程操作字符串缓冲区下操作大量数据 = StringBuffer

## 自动装箱与拆箱
装箱：将基本类型用它们对应的引用类型包装起来；
拆箱：将包装类型转换为基本数据类型；
##  在一个静态方法内调用一个非静态成员为什么是
非法的
由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非
静态变量，也不可以访问非静态变量成员。
##  在 Java 中定义一个不做事且没有参数的构造
方法的作用
Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定
的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定
义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类
中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没
有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数
的构造方法。
##  import java 和 javax 有什么区别
刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展
API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组
成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏
一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。
所以，实际上 java 和 javax 没有区别。这都是一个名字。
##  接口和抽象类的区别是什么
1. 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始
接口方法可以有默认实现），抽象类可以有非抽象的方法

2. 接口中的实例变量默认是 final 类型的，而抽象类中则不一定

3. 一个类可以实现多个接口，但最多只能实现一个抽象类

4. 一个类实现接口的话要实现接口的所有方法，而抽象类不一定

5. 接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口
的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是
行为的抽象，是一种行为的规范。

##  成员变量与局部变量的区别有那些
1. 从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的
变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所
修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员
变量和局部变量都能被 final 所修饰；

2. 从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存
在于堆内存，局部变量存在于栈内存

3. 从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对
象的创建而存在，而局部变量随着方法的调用而自动消失。

4. 成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情
况例外被 final 修饰的成员变量也必须显示地赋值）；而局部变量则不
会自动赋值。

##  创建一个对象用什么运算符?对象实体与对象引用有何不同?
new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象
实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象
（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向
它（可以用 n 条绳子系住一个气球）。

## 什么是方法的返回值?返回值在类的方法里的作用是什么?

方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前
提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他
的操作！

## 一个类的构造方法的作用是什么 若一个类没有声明构造方法,该程序能正确执行吗 ?为什么?
主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明
构造方法也会有默认的不带参数的构造方法。
##  构造方法有哪些特性
1. 名字与类名相同；

2. 没有返回值，但不能用 void 声明构造函数；

3. 生成类的对象时自动执行，无需调用。

## 静态方法和实例方法有何不同
1. 在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对
象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用
静态方法可以无需创建对象。

2. 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量
和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无
此限制.

##  对象的相等与指向他们的引用相等，两者有什么不同？
对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们
指向的内存地址是否相等。

##  在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是?
帮助子类做初始化工作

##  == 与 equals(重要)

== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同
一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)
equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
* 情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个
对象时，等价于通过“==”比较这两个对象。
*  情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来
两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两
个对象相等)。
举个例子：
```
public class test1 {
 public static void main(String[] args) {
 String a = new String("ab"); // a 为一个引用
 String b = new String("ab"); // b 为另一个引用,对象的内容一样
 String aa = "ab"; // 放在常量池中
 String bb = "ab"; // 从常量池中查找
 if (aa == bb) // true
 System.out.println("aa==bb");
 if (a == b) // false，非同一对象
 System.out.println("a==b");
 if (a.equals(b)) // true
 System.out.println("aEQb");
 if (42 == 42.0) { // true
 System.out.println("true");
 }
 } }
 ```
说明：

* String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是
比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。
* 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存
在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没
有就在常量池中重新创建一个 String 对象。

## hashCode 与 equals（重要）
面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals
时必须重写 hashCode 方法？”

hashCode（）介绍

hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整
数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义
在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函
数。

散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应
的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）
为什么要有 hashCode
我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：
当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断
对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如
果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有
相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相
等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。
如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head
first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高
了执行速度。

hashCode（）与 equals（）的相关规定

1. 如果两个对象相等，则 hashcode 一定也是相同的

2. 两个对象相等,对两个对象分别调用 equals 方法都返回 true

3. 两个对象有相同的 hashcode 值，它们也不一定是相等的

4. 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖

5. hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写
hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个
对象指向相同的数据）

## 为什么 Java 中只有值传递
为什么 Java 中只有值传递？
##  简述线程，程序、进程的基本概念。以及他们之间关系是什么
线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的
过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空
间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工
作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。
程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就
是说程序是静态的代码。

进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态
的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，
一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行
着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，文
件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系
统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同
在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有
可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段
时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执
行一个以上的程序段。

## 线程有哪些基本状态?
参考《Java 并发编程艺术》4.1.4 节。
Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中
一个状态。

线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态
之间切换。Java 线程状态变迁如下图所示：
## 关于 final 关键字的一些总结

final 关键字主要用在三个地方：变量、方法、类。
1. 对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始
化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不
能再让其指向另一个对象。

2. 当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员
方法都会被隐式地指定为 final 方法。

3. 使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承
类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将
final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用
带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行
这些优化了）。类中所有的 private 方法都隐式地指定为 final。

## Java 中的异常处理
Java 异常类层次结构图

在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable
类。Throwable： 有两个重要的子类：Exception（异常） 和 Error（错
误） ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。

Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大
多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟
机）出现的问题。例如，Java 虚拟机运行错误（Virtual MachineError），当
JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这
些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。

这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如
Java 虚拟机运行错误（Virtual MachineError）、类定义错误
（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的
控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设
计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它
所引起的异常状况。在 Java 中，错误通过 Error 的子类描述。

Exception（异常）:是程序本身可以处理的异常。Exception 类有一个重要的
子类 RuntimeException。RuntimeException 异常由 Java 虚拟机抛出。
NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）、
ArithmeticException（算术运算异常，一个整数除以 0 时，抛出该异常）和
ArrayIndexOutOfBoundsException （下标越界异常）。

注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。
Throwable 类常用方法

* public string getMessage():返回异常发生时的详细信息
* public string toString():返回异常发生时的简要描述
*  public string getLocalizedMessage():返回异常对象的本地化信息。使
用 Throwable 的子类覆盖这个方法，可以声称本地化信息。如果子类没
有覆盖该方法，则该方法返回的信息与 getMessage（）返回的结果相同
* public void printStackTrace():在控制台上打印 Throwable 对象封装的
异常信息
异常处理总结
* try 块：用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch
块，则必须跟一个 finally 块。
*  catch 块：用于处理 try 捕获到的异常。
*  finally 块：无论是否捕获或处理异常，finally 块里的语句都会被执行。
当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回
之前被执行。

在以下 4 种特殊情况下，finally 块不会被执行：

1. 在 finally 语句块中发生了异常。

2. 在前面的代码中用了 System.exit()退出程序。

3. 程序所在的线程死亡。

4. 关闭 CPU。

## Java 序列化中如果有些字段不想进行序列化 怎么办
对于不想进行序列化的变量，使用 transient 关键字修饰。
transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；
当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。
transient 只能修饰变量，不能修饰类和方法。
## 获取用键盘输入常用的的两种方法

方法 1：通过 Scanner
Scanner input = new Scanner(System.in);
String s = input.nextLine();
input.close();

方法 2：通过 BufferedReader
BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
String s = input.readLine();

# 其他
喜欢的同学点个星星，打赏奖励一下博主！！！

 <img src="https://img-blog.csdnimg.cn/20210414173956371.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlMzY5MDkzNDU3,size_16,color_FFFFFF,t_70" width = "200" height = "250" alt="图片名称" align=center />
 <img src="https://img-blog.csdnimg.cn/20210414174007800.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tlMzY5MDkzNDU3,size_16,color_FFFFFF,t_70" width = "200" height = "250" alt="图片名称" align=center />
 